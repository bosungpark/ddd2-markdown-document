JPA를 이용한 리포지터리 구현
=
리파지터리 인터페이스는 어그리거트 루트를 기준으로 작성한다.

어그리거트에서 루트 앤티티를 제외한 나머지 구성요소는 대부분 밸류이다. 루트 앤티티 이외에 다른 앤티티가 있다면 진짜 앤티티인지 의심해봐야 한다.
단순히 별도에 테이블에 있다고, 앤티티는 아니다.

밸류가 아니라 앤티티가 확실하다면, 해당 앤티티가 다른 어그리거트는 아닌지 확인 해야 한다.
자신만의 독립된 라이프사이클을 가진다면, 다른 어그리거트일 가능성이 높다.

어그리거트에 속한 객체가 밸류인지 앤티티인지 구분하는 방법은 고유 식별자를 갖는지 확인하는 것이다.
하지만 식별자를 찾을 때 매핑되는 테이블의 식별자를 어그리거트의 구성요소의 식별자와 동일한 것으로 착각하면 안된다.
별도의 테이블로 저장하고 PK가 있더라도 테이블과 매핑되는 어그리거트의 구성요소가 항상 고유 식별자를 가지는 것은 아니기 때문이다.

** prod, sku의 경우 trx의 밸류인가? 엔티티인가? cascade

어그리거트 로딩 전략
=
어그리거트에 속한 객체가 모두 모여야 완전한 하나가 된다.
조회 시점에 어그리거트를 완전한 상태로 되도록 하려면 어그리거트 루트에서 연관 매핑의 조회방식을 즉시로딩으로 하면 된다. (단 컬렉션에 대해 즉시 로딩은 해로울 수도 있다.)

어그리거트가 완전해야 하는 이유는 1. 상태변경, 2. view적인 요구사항이다.

상태변경을 위한 경우라면, 지연 로딩도 고민해 볼만 하다.

어그리거트의 영속성 전파
=
어그리거트가 완전해야 한다는 것은 어그리거트 루트를 조회할 때 뿐만 아니라 저장하고 삭제할 때에도 하나로 처리해야함을 의미한다.

식별자 생성기능
=
- 사용자가 직접 생성
- 도메인 로직으로 생성
- DB를 이용한 일련번호 생성

도메인 구현과 DIP
=
이상적인 DIP를 할 수도 있지만, 변경될 가능성이 적은 기술에 대해서는 적당한 타협도 나쁘지 않다.

